#!/usr/bin/php -q
<?php

/**
 *  @file
 *  A script to enforce ownership of drupal and wordpress webroots.
 */

/**
 *  This script is designed to enforce ownership settings on a wordpress or
 *  drupal webroot. Permissions are defined n the 3 dimensional array called
 *  $desired_settings. All files are checked first to see if any settings need
 *  to be changed; if so, changes are attempted. Both successes and failures
 *  are logged (log file is ./setown.log). Failures also generate error
 *  messages in STDOUT.
 *
 *  Written by Chris McDermott, AppliedTrust, chris@appliedtrust.com
 *    v1.1 7/16/2011
 *
 *  @param platform
 *    Specify the software platform to check. Acceptable values are
 *    "wordpress", "drupal6", and "drupal7".
 *  @param target
 *    Specify the directory where the software platform is installed. This is
 *    the base directory used for all file interactions.
 *  @param owner
 *    Specify a default owner for files in the webroot (perhaps the primary
 *    developer). This is an optional parameter - if it is omitted this
 *    defaults to "root".
 *  @param group
 *    Similar to the owner parameter - this is the default group that should be
 *    applied to webroot files. This is an optional parameter - if it is
 *    omitted this defaults to "root".
 *  @param webuser
 *    Optional. Sets the user account in use by the web server (for things lik
 *    e file upload directories). Defaults to "apache".
 *  @param debug
 *    Optionally enable extra debugging statements.
 *
 *  @return
 *    Returns true if no errors were encountered, false otherwise.
 */
putenv('TZ=America/Denver');
$debug = 0;
$logfile = "./setown.log";

// Start parsing arguments
$options = getopt("p:t:o:g:w:dh");
if (isset($options["h"])) { usage(); };
if (!isset($options["p"])) { 
  log_this("error", "-p option is required."); 
  usage(); 
}
if (!isset($options["t"])) { 
  log_this("error", "-t option is required."); 
  usage(); 
}
if (isset($options["o"])) { 
  if (!user_exists($options["o"])) {
    log_this("error", "User: " . $options["o"] . " does not exist, please specify a valid user account.");
    exit(2);
  }
  $owner = $options["o"]; 
}

//  If no owner is provided, default to "root".
else {
  $owner = "root"; 
}

if (isset($options["g"])) { 
  if (!group_exists($options["g"])) {
    log_this("error", "Group: " . $options["g"] . " does not exist, please specify a valid group.");
    exit(2);
  }
  $group = $options["g"]; 
}

//  If no group is provided, default to "root".
else {
  $group = "root";
}

if (isset($options["w"])) { 
  $webuser = $options["w"]; 
}
//  If no webuser is provided, default to "apache".
else {
  $webuser = "apache";
}

if (($options["p"] != "wordpress") && ($options["p"] != "drupal6") && ($options["p"] != "drupal7")) { 
  log_this("error", "$options[p] is not a supported platform."); 
  usage(); 
}

if (isset($options["d"])) { $debug = 1; }
$platform = $options["p"];
$target = $options["t"];

//  If debug was toggled, log all arguments
if ($debug) {
  foreach($options as $key=>$value) {
    log_this("debug", "option $key: $value");
  }
}

//  If the target directory doesn't exist, bail out with an error.
if (!file_exists($target)) {
  log_this("error", "$target does not exist.");
  exit(2);
}

//  If the target directory doesn't look like an installation of the specified
//  platform, bail out with an error.
elseif (!validate_target($platform, $target)) {
  log_this("error", "$target does not look like a valid $platform webroot.");
  exit(2);
}

// If the $target has a trailing slash, get rid of it.
if (preg_match("/(.*)\/$/", $target, $matches)) {
  $target = $matches[1];
}

$successes = array();
$errors = array();

/**
 *  @array $desired_perms
 *    A 3 dimensional array of ownership settings for each platform.
 *    -platform: An array of supported platforms:
 *      -file: An array of settings for the named file:
 *        -owner: A string specifying the desired owner.
 *        -group: A string specifying the desired group.
 */
$desired_perms = array(
  "wordpress" => array( 
    "wp-admin" => array(
      "owner" => "root",
      "group" => "root",
    ),
    "wp-content" => array(
  	  "owner" => $owner,
  	  "group" => $group,
    ),
    "wp-includes" => array(
      "owner" => "root",
      "group" => "root",
    ),
    "wp-content/uploads" => array(
     "owner" => $webuser,
     "group" => $group,
    ),
    ".htaccess" => array(
      "owner" => "root",
      "group" => "root",
    ),
  },
  "drupal6" => array(
    "cron.php" => array(
      "owner" => $owner,
      "group" => $group,
    ),
  ),
  "drupal7" => array(
    "cron.php" => array(
      "owner" => $owner,
      "group" => $group,
    ),
  ),
);

//  Iterate through each file in the array of settings for the provided platform
//  and apply the settings to it.
foreach ($desired_perms[$platform] as $file=>$setting) {
  if (!file_exists("$target/$file")) { continue; };
  apply_settings("$target/$file", $setting["owner"], $setting["group"]);
}

//  Check for errors, return true or false, depending.
if (count($errors) == 0) {
  return true;
}
else {
  return false;
}

/**
 *  Prints usage information and argument requirements.
 */
function usage () {
  echo "Usage: at_setperms -p <wordpress|drupal6|drupal7> -t <targetdir> [-o owner] [-g group] [-d]\n";
  echo "  -p platform         drupal6|drupal7|wordpress         required\n";
  echo "  -t target           /var/www/html/wordpress           required\n";
  echo "  -o owner            username                          optional, defaults to root\n";
  echo "  -g group            groupname                         optional, defaults to root\n";
  echo "  -w webuser          username(apache,www-user)         optional, defaults to apache\n";
  echo "  -d                                                    optional, toggles debug\n\n";
  exit (2);
}

/**
 *  Logs a message.
 *  
 *  Supports various message types, including debug, error, and info. Debug 
 *  messages are printing to STDOUT, while error messages are printed to STDOUT 
 *  and the log file, and info messages are only printed to the log file.
 *
 *  @param string $type
 *    "debug" and "error" are handled specially, everything else ("info", for
 *    instance) is just written to the log file.
 *
 *  @param string $message
 *    The message to log. Newline is appended to the end automatically, so
 *    there's no need to include it.
 */
function log_this ($type, $message) {
  global $logfile, $debug;
  $handle = fopen($logfile, "a");
  $timestamp = date("Y-m-d H:i") . "\t";
  if ($type == "error") {
    echo "ERROR: " . $message . "\n";
    fwrite($handle, $timestamp . $message . "\n");
  }
  elseif (($type == "debug") && ($debug == 1)) {
    echo "DEBUG: " . $message . "\n";
    //fwrite($handle, $timestamp . $message . "\n");
  }
  else {
    fwrite($handle, $timestamp . $message . "\n");
  }
  fclose($handle);
}

/**
 *  Checks the target location provided to ensure that it looks like a valid 
 *  $platform webroot.
 *
 *  @param string $platform
 *    Web platform to check for - "wordpress" or "drupal6" or whatever.
 *  @param string $target
 *    The target location to check.
 *
 *  @return
 *    True if the webroot is confirmed to be a $platform install, otherwise
 *    false.
 */
function validate_target ($platform, $target) {
  if ($platform == "wordpress") {
    if(!file_exists("$target/wp-config.php") || !file_exists("$target/wp-admin/") || !file_exists("$target/wp-content/")) {
      return false;
    }
    else { return true; }
  }
  else if (preg_match("/drupal/", $platform)) {
    if(!file_exists("$target/sites/default/settings.php") || !file_exists("$target/includes/") || !file_exists("$target/modules/node/")) {
      return false;
    }
    else { return true; }
  }
  else {
    log_this("error", "Could not validate target directory, are you sure that $platform is a valid platform?");
    return false;
  }
}

/**
 *  Sets owner and group of specified file.
 *
 *  Owner and group are checked first, and if the settings are already correct,
 *  no action is taken. If they are not correct, the owner and/or group is
 *  changed appropriately. If the file is a directory, a find command
 *  identifies any files or subdirectories that also require changes, and the
 *  function is called recursively on each of those.
 *
 *  All changes, whether successful or not, are logged.
 *
 *  @param $file
 *    Full path to file.
 *  @param $owner
 *    User name of desired owner.
 *  @param $group
 *    Name of desired group.
 *
 *  @return
 *    True if the settings were applied successfully, otherwise false.
 */
function apply_settings ($file, $owner, $group) {
  global $debug, $errors, $desired_perms, $platform;
  if (in_array($file, $errors)) { return false; }
  //  Parse for just the filename
  if (preg_match("/.*\/([^\/]+)$/", $file, $matches)) {
    //  If that exists in desired_perms then skip it, since we'll come back
    //  to it later.
    if (array_key_exists($matches[1], $desired_perms[$platform])) {
      return false;
    }
  }
  $uid_info = posix_getpwuid(fileowner($file));
  $gid_info = posix_getgrgid(filegroup($file));
  $current_owner = $uid_info["name"];
  $current_group = $gid_info["name"];
  switch (filetype($file)) {
    case "file": 
      if ($current_owner != $owner) {
        change_owner($file, $owner);
      }
      if ($current_group != $group) {
        change_group($file, $group);
      }
      break;
    case "dir":
      if ($current_owner != $owner) {
        change_owner($file, $owner);
      }
      if ($current_group != $group) {
        change_group($file, $group);
      }
      //  Find any files not owned by $owner or $group, and fix them recursively.
      exec("find $file -not -user $owner", $owner_files);
      exec("find $file -not -group $group", $group_files);
      if (count($owner_files) > 0) {
        foreach ($owner_files as $bad_file) {
          apply_settings($bad_file, $owner, $group);
        }
      }
      if (count($group_files) > 0) {
        foreach ($group_files as $bad_file) {
          apply_settings($bad_file, $owner, $group);
        }
      }
      break;
  }
  //  Check to see if changes were successful.
  $new_uid_info = posix_getpwuid(fileowner($file));
  $new_gid_info = posix_getgrgid(filegroup($file));
  $new_current_owner = $new_uid_info["name"];
  $new_current_group = $new_gid_info["name"];
  if (($new_current_owner == $owner) && ($new_current_group == $group)) {
    return true;
  }
  else {
    return false;
  }
}

/** 
 *  Changes the owner of specified file.
 */
function change_owner ($file, $owner) {
  global $successes, $errors;
  $uid_info = posix_getpwuid(fileowner($file));
  $current_owner = $uid_info["name"];
  exec("/bin/chown $owner $file 2>&1 > /dev/null", $output, $return);
  if (!$return) {
    log_this("info", "Changed owner of $file from $current_owner to $owner.");
    array_push($successes, $file);
    return true;
  }
  else {
    log_this("error", "Failed to change owner of $file from $current_owner to $owner.");
    array_push($errors, $file);
    return false;
  }
}

/** 
 *  Changes the group of specified file.
 */
function change_group ($file, $group) {
  global $successes, $errors;
  $gid_info = posix_getgrgid(filegroup($file));
  $current_group = $gid_info["name"];
  exec("/bin/chgrp $group $file 2>&1 > /dev/null", $output, $return);
  if (!$return) {
    log_this("info", "Changed group of $file from $current_group to $group.");
    $successes++;
    return true;
  }
  else {
    log_this("error", "Failed to change group of $file from $current_group to $group.");
    $errors++;
    return false;
  }
}

/** 
 *  Checks if the specified group exists.
 */
function group_exists ($group) {
  exec("/bin/grep $group: /etc/group", $output, $return);
  if ($return != 0) {
    return false;
  }
  return true;
}

/**
 *  Checks if the specified user exists.
 */
function user_exists ($user) {
  exec("/bin/grep $user: /etc/passwd", $output, $return);
  if ($return != 0) {
    return false;
  }
  return true;
}

?>
